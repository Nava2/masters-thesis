\chapter{Conclusion}
\label{ch:conclusion}

This thesis examined the topic of education for Computer and Software Engineering students on the subject of embedded systems and Instruction Set Architectures. While ultimately unsuccessful in developing a working solution, we have provided a series of known working and invalid approaches to solving the problem outlined in \cref{sec:problem-statement}. We proposed a framework of requirements for a solution to work in the modern laboratory and investigated two major solutions. The first implementation used Scala and the distributed framework Akka to develop a massively asynchronous solution to representing an ISA. In addition, this project investigated the use of a Scala program as a configuration definition. We then implemented a set of novel test and build infrastructure components to better build cross-platform C++ applications. Lastly, we used the knowledge gained from the first and second projects to iterate on an existing project and create a Lua-based configuration system for the desktop. The last chapter included a ``compiler''-like implementation of state-machine representations of a microinstruction and showcased a configuration language capable of defining a full Turing-complete machine. In this chapter, we will summarize the main contributions from each chapter and use the lessons learned to propose future goals for this research question. 

In the following sections, we reiterate our contributions and provide recommendations for future work based on post-mortem analysis of our projects discuss in previous chapters.  

\section{Contributions}

\paragraph{\nameref{ch:prev-other-work}} We provided a quantitative application of the requirements outlined in the Problem Statement within \cref{sec:problem-statement} with previous works in use today. From these existing technologies, we also extracted key features that should be built into new solutions going forward. Many of the existing simulations technologies surveyed use dated software tools to build them and do not provide ample interfaces focused on human computer interaction concepts from the student's perspective. 

\paragraph{\nameref{ch:scala-akka}} \Cref{ch:scala-akka} proposed a web application known as procsim.scala built on the Scala.js platform using Akka and Akka.js to simulate a custom, massively parallel processor in a synchronous JavaScript environment. We outlined a DSL language for specifying a microinstruction's execution within a Scala script. We also pushed the envelope for state-of-the-art utilizing emerging tools in a novel environment. Regrettably, these emerging tools could not maintain a high performing application at the time.

\paragraph{\nameref{ch:cross-platform}} We discussed an anecdotal account of refactoring the hc12sim project into a modern C++ environment. Through the recount, we proposed infrastructure improvements to test large native applications within multiple platforms while on a single host platform through Vagrant and Oracle's VirtualBox. Further, we developed a project-based CMake pattern to better organize build scripts and ease application development improving agility through build improvements. The improvements for CMake allowed for faster build times and over-all less time spent in compilation. Lastly, implementing a proper continuous integration work flow through the previous developments and Jenkins we provide a simple mechanism for validation within the context of developing a cross-platform C++ application.

\paragraph{\nameref{ch:lua}} We evaluated the use of four scripting languages within a C++ application as an embedded language runtime. Each of these languages were evaluated and Lua was selected as the optimal choice due to proved use in high-performance applications, ease of embedding and data-description capabilities. We implemented a processor description within Lua that allowed for fully Lua-compliant scripts to describe the modules of a simple architecture. Within this definition, we provided a design for instruction state change microcoding through unintrusive side-effect-based execution which was compiled to events within a simulation engine. This representation hid a lot of implementation details hoping to improve student outcomes, however we realized that through utilizing such high-level constructs to teach low-level hardware design we lost a lot of necessary context.

\section{Recommendations}

While our work in this thesis did not produce a fully working prototype, we developed many contributions towards future work in developing teaching simulation tools for embedded systems and hardware-software co-design. Through our work, we hope others can improve their tooling to close the open problem of improving teaching of a difficult subject for many students. We recommend the following improvements to our models and existing software. 

\paragraph{Remove the requirement for real-time simulations.} Naively, we intended to implement simulations at real-time speeds of older architectures. When implementing the hc12sim project in \cref{sec:hc12sim}, we produced a real-time simulation of the \hcmodel{}. This was an admirable goal, but the cost of this meant utilizing native tools and imposing design requirements that proved undesirable to the pedagogical outcome of the simulations. Maintaining a behaviourally accurate simulation at the cost of speed of execution is a valid if not beneficial trade-off. When implementing Akka.js, \cite{Doeraene2014} showcased that asynchronous software does not necessitate parallelism. By removing parallelism, it opens technology choices we could not previously utilize and allows for a more simplistic simulation engine implementation. 

\paragraph{Investigate functional style component development through reactive frameworks.} Akka's model for distributed systems is necessary when dealing with bidirectional data flow within an application. We have realized that for circuits and hardware simulation, data flow is generally unidirectional in that signals are passed onto a connection. This is evidenced by how HDL languages like VHDL often treat hardware specifications as input-output connected black boxes. Since developing the procsim.scala project, there has been a movement within the reactive community to produce a series of libraries known as ReactiveX that utilize unidirectional program flow to reduce software complexity within asynchronous applications \cite{ReactiveX:HomePage}. With processor simulation being an asynchronous system, these libraries could simplify application development significantly. Further, the ReactiveX community provides implementations for most major programming environments including Java \cite{ReactiveX:Java}, Scala \cite{ReactiveX:Scala} and JavaScript \cite{ReactiveX:JS}. 

\paragraph{Use a bisecting design between Lua-based control units and Emumaker86's (\cite{Black2013}) state-table.} The process of compiling the Lua specifications of instruction microcode, we accidentally hid a lot of information to students. We allowed them to quickly define designs, but as others found \cite{Ackovska2014,Djordjevic2005,McLoughlin2010,Nakamura2013,Black2013} students benefit from getting into the deeper design of a hardware architecture. We believe the work completed by \cite{Black2013} to provide a distinction between hardware data paths and the control unit provides a ``deep enough'' philosophy for students to learn how these concepts work without holding them back. We suggest improvements on their model by utilizing state charts over state tables and developing mechanisms to better organize the information into ``modules'' of state for repeatability -- something our Lua configurations allowed through variable declarations. 

\paragraph{Utilize modern web technologies over desktop applications.} While a large component of our work completed in \cref{ch:cross-platform,ch:lua} involved native applications, we believe the best environment for students in a modern classroom is through web applications. With the performance of modern JavaScript in the browser, we believe students are more likely to enjoy computer architecture discussions if the tools they utilize are within comfortable environments. Additionally, we found much higher productivity when working with Scala.js than with our C++ applications. While improving the developer work flow for C++, we continually fought with multiple platforms and massive tool-chain differentiation. We believe JavaScript and modern web technologies give the best of developer productivity and modern applications to reduce the time taken to develop and iterate on these tools. 

\section{Future Work}

For any work going forwards, we believe the lessons learned in this thesis provide a through starting point for a project. We expect future work would include a web-based solution that takes advantage of reactive components to provide an accurate and easy to develop and iterate solution. By utilizing these modern tools, paradigms, and testing knowledge we firmly believe a solution could be created that caters to all of our requirements outlined in \cref{sec:problem-statement}. 
