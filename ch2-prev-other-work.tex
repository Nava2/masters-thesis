\chapter{Survey of other and previously completed works}
\label{ch:prev-other-work}

\section{Previous Work: hc12sim}
\label{sec:hc12sim}

In 2013, we worked collaboratively with colleague and fellow student Ramesh Raj to build a behaviourally accurate simulator for the \hcmodel{} processor. This work was completed as part of our capstone project for a Computer Engineering degree from \uwo{} \cite{Brightwell2013}. This software was produced over 2013-2014 and had the following features: 

\begin{enumerate}
    \item Included memory element simulation for the \hcmodel{} architecture (e.g. registers, RAM, ROM)
    \item Compile-time configurable microinstructions (addressing modes were not configurable)
    \item Real-time simulation speeds for the \hcmodel{}
    \item Debugging of assembly code with runtime viewing of internal hardware components
    \item Accurate CISC addressing modes as specified by \hcmodel{}
    \item Feature complete assembler creating exact machine code
    \item Simple IDE for writing \hcmodel{} assembly code, compiling and simulating it (shown in \cref{fig:hc12ide-invalid-instruction})
\end{enumerate}

\begin{figure}[bh!]
    \centering
    \includegraphics[width=0.6\linewidth]{img/hc12ide-invalid-instruction}
    \caption{hc12ide Integrated Development Environment showing a student error in an incorrect specification of an instruction mnemonic.}
    \label{fig:hc12ide-invalid-instruction}
\end{figure}

\subsection{Software Design}

This project was written in C++ utilizing modern C++11 features such as lambdas, closures and cross-platform libraries (e.g. Qt and Boost\footnote{Available: Qt (\url{https://www.qt.io}) and Boost (\url{https://boost.org/})}). The primary design goals for the hc12sim project were:
\begin{enumerate}
    \item Support all three major platforms: Microsoft Windows, macOS, and GNU/Linux
    \item Separate compiler and simulation components
    \item Completely decouple any IDE from the simulation engine
    \item Heavily unit-test all software components for validity confirmation
\end{enumerate}
\noindent The goals set for the hc12sim project closely mimic the requirements set in \cref{sec:problem-statement}.
Given these design goals, supporting technologies were assessed against the following requirements (in order of priority): 
\begin{enumerate}
    \item User interface library available
    \item Access to low-level types
    \item Fast enough for simulation
\end{enumerate}

\noindent While initially writing the software in Java utilizing Java's Swing Toolkit and the Java Standard Library, it was rewritten in C++ due to access of low-level unsigned types, method references and multithreading capabilities. Java's current Java 8 release added these features, however the Java 8 release was not available at the time of creation outside of ``beta'' environments.

\subsubsection{Instructions}
\label{sec:hc12sim:instruction-generation}

Due to the \hcmodel{} having over 200 instructions with multiple addressing modes for each \cite{hc12Manual2006}, the simulation and assembler libraries put heavy emphasis on generating code to simplify writing and adding instructions. This allowed for generating multiple classes that had all of the meta-information required for all stages of a program (writing, assembly, programming, execution). In order to configure and ensure the quality of the large amount of generation required, a custom user interface was created to easily load and store data and generate C++ code. \Cref{fig:hc12sim-instruction-generater-ui} showcases the interface created for code generation. The primitive interface supported choosing an instructions supported addressing modes and writing the transformations required within the small code window (bottom right of \cref{fig:hc12sim-instruction-generater-ui}). The generator interface did not support any syntax highlighting for the C++ code required and performed ``magic'' code injection upon generation \cite[Table~3-1,~p.~30]{hc12Manual2006} In addition to the user interface, the generator back-end was built into a command-line tool that allowed the generation to be run at compile time when hooked into build scripts (in this case, CMake \cite{Kitware:CMake}). The user interface generated JSON entries similar to that shown in \cref{lst:hc12sim-json-beq}. The ``body'' field is injected into a method header for the execution engine and the other information is used in either compiling or execution as meta-information.

\begin{figure}[h!t]
    \centering
    \includegraphics[width=0.6\linewidth]{img/hc12sim-instruction-generater-ui}
    \caption{hc12sim Instruction Generator showing the meta information for addressing modes, execution, and output.}
    \label{fig:hc12sim-instruction-generater-ui}
\end{figure}

\begin{listing}[htp]
\begin{minted}{json}
{
    "BEQ": {
        "body": "
            auto ccr = cpu->CCR();
            bool _Z = ccr->get(Z);
            if ( _Z ) {
                int8_t rel = math::toSys<int8_t>(resbytes[0]);
                cpu->PC()->inc(rel);
            }
        ",
        "cycles": 1,
        "handlePC": false,
        "types": {
          "REL8": "27"
        }
  },
}
\end{minted}
\caption{Sample of the JSON output used to generate code within hc12sim. BEQ performs a branch if two values were equal.}
\label{lst:hc12sim-json-beq}
\end{listing}

\subsubsection{Hardware Simulation}
\label{sec:hc12sim:sec:hardware-simulation}

Physical modules within the simulation model were all individual custom classes. For example, the \verb|A| and \verb|B| registers were of \cxxinline{class Register<size_t width>} where the \verb|width| template parameter defined the bit width of the \cxxinline{Register}. Regrettably, any special behaviours were ``decorated'' on top of the base type creating many different types depending on how the underlying component was used. Using the pattern of ``compile-time constant templates'' created issues when trying to use these types in polymorphic aggregate containers. For example, if a \cxxinline{Register<8> A} is defined and a \cxxinline{Register<16> X} \cxxinline{typeof A} is not the equal to \cxxinline{typeof X} as templated types are created at instantiation time making the type of a variable a ``new'' type (reuse happens when available) \cite{cppreference:class-template}. This created confusing class hierarchies and directly contradicts advice of the Decorator pattern \cite[p.~175]{go4} creating large concerns for maintainability. Of particular interest was the design of the \cxxinline{class Timer} and \cxxinline{class TimerDependant} types which allowed for completely concurrent, event-based timing. While these concurrent timing modules were fast and well designed, it created problems with discrete execution as each component operates concurrently in separate thread contexts and can not be ``stepped'' through without executing all of the threaded operations simultaneously. In addition, each \cxxinline{TimerDependant} added a thread of execution adding runtime overhead to simulation while reducing functionality of the simulation. Due to our ignorance at the time, neither thread nor fork-join pools were used to reduce the thread ``spin-up'' performance penalty. Further, the synchronization properties of this scheme reduced to near-synchronous execution with the time taken to check locks and mutexes likely costing more time than the savings of parallelism afforded -- not to mention the required knowledge of maintaining a highly parallel code base.

%\begin{figure}[!hp]
%    \begin{minipage}{.5\linewidth}
%        \centering
%        \includegraphics[width=\textwidth]{img/hc12sim-timer-sequence} 
%    \end{minipage}%
%    \begin{minipage}{.5\linewidth}
%        \begin{enumerate}
%            \item A \cxxinline{Timer} object is instantiated and started, it will enter sleep state
%            \item Two \cxxinline{TimerDependant} objects are created with execution methods bound within.
%            \item The \cxxinline{Timer} object binds the two \cxxinline{TimerDependant} objects to itself
%            \item In the \cxxinline{Timer}'s thread, it wakes and asks the Operating system to simultaneously signals all \cxxinline{TimerDependant} objects to wake
%            \item Synchronously, all the \cxxinline{TimerDependant} objects:
%            \begin{enumerate}
%                \item Run it's own execution method within it's thread
%                \item Return to a sleep-state and wait for next notification
%            \end{enumerate}
%        \end{enumerate}
%    \end{minipage}
%    \caption{Sequence of events for \cxxinline{Timer} and two \cxxinline{TimerDependant} modules interaction \cite{Brightwell2013}} 
%    \label{fig:hc12sim-timer-seq}
%\end{figure}

\subsubsection*{Execution}

The simulator implemented execution through an \cxxinline{class Executor} that asynchronously executes the execution scheme specified by the \hcmodel{} \cite[Sec.~4,~p.~47]{hc12Manual2006} which was implemented in terms of \cite[p.~59]{Vahid2002}. The \cxxinline{Executor} utilized a fetch, decode, fetch (if needed), execute loop for executing all instructions. The actual execution of an instruction was completed directly by static code written in the instruction generation step (see \cref{sec:hc12sim:instruction-generation} for more information). However, the generated code is run within a separate thread context to keep the ``clock'' of the system running at a consistent speed. Of particular note, this simulation could not handle interrupts or pipe-lining. Due to the reliance on the timing mechanisms discussed in \cref{sec:hc12sim:sec:hardware-simulation}, the execution engine suffered from the same ``synchronous'' parallelism. Further, if the clock speed was too fast and execution actions moved too slowly, the result was an non-determinant clock skew over time.

%\begin{figure}[!ph]
%    \centering
%    \includegraphics[width=.9\linewidth]{img/hc12sim-execunit-sequence}
%    \caption{Sequence diagram of Execution process within Simulator}
%    \label{fig:hc12sim-execunit-sequence}
%\end{figure} 

\section{Evaluation of existing simulation technologies} 
\label{sec:review}

Presented in the following sections are a series of similar projects attempting to tackle the same solution space as the work of this thesis. Each software tool is evaluated against the requirements from \cref{sec:problem-statement}. The intention of this evaluation is dual:
\begin{enumerate}
    \item Find previous works that could be expanded upon and improved to match this thesis' requirements rather than building a new solution in a ``green field''
    \item Extract features from other simulation technologies that are beneficial to future technology
\end{enumerate}
\noindent Each simulation project is rated based on the requirements out of five and totalled to create a quantitative matrix of requirements. Each rating contains justifications for the rating assigned following \cref{sec:review-prev-hc12sim}. 

\subsection{Methodology}
\label{sec:review:methodology}

Holistically, we attempted to find the best solution for each requirement outlined in \cref{sec:problem-statement}. To do this we created a ranking of each of our considered software and applied a rating of zero to five with zero being the worst, and five being the best matching of each requirement. Within this specification, we believe some requirements were not met by any of the software evaluated. For example, there is no ``best'' software in our opinion that met \cref{req:modern} perfectly with having a modern user interface. Our methodology allows for a relative, though opinion-based, approach to contrasting existing solutions.  

\subsection{hc12sim}
\label{sec:review-prev-hc12sim}

The hc12sim project was very immature and not well implemented in the presented state. hc12sim managed to provide a solution for all of the required platforms when distributed as individual platform specific binaries. The hc12ide was a desktop application and bound to the technology choice of C++, there is no possibility of using the software outside the desktop without large software porting efforts. Unfortunately, building C++ applications such that they can be distributed to cross-platform targets is labour intensive and very difficult without the correct amount of knowledge -- knowledge that was lacking at the time of authorship. Binaries worked for some and often only worked with specific unknown environmental state requirements (particularly with Windows environments). Regarding \cref{req:personal}, the project meets the requirement adequately, but does not do enough. Configuration of the ISA is provided through the JSON-driven mechanism for instruction generation but this mechanism only worked as a compile-time configuration. If students wanted to change the ISA for their processor, it required rebuilding the entire project and testing to see that it worked manually. This was aided by the use of the ``Instruction Generator'' described in \cref{sec:hc12sim:instruction-generation} but does not remove the requirement of building requiring a large compiler tool-chain. Further, without any support for hardware configuration the project did not meet \cref{req:configuration}. hc12sim heavily favoured \cref{req:pedagogical} as it was intended to create a simulator that was behaviourally accurate to the \hcmodel, but only if it allowed students to better understand how the processor works.

The simulation interface allowed for debugging at an instruction level and setting break points within execution contexts. During an execution, all component states could be viewed -- except for the memory. The project also assembled fully compliant machine code that could potentially be programmed to a real machine. Unfortunately, peripherals and interrupts were not supported. While including these flaws, the hc12sim project provides a poor match for \cref{req:simulations}. Lastly, while the user interface does not have all of the features of a full IDE, it did provide syntax highlighting, and assembler plus simulation controls in an easy to use interface. \Cref{req:modern} is adequately met, however it requires updates to the editor interface to improve modern facilities.

\begin{table}[h!]
    \centering
    \begin{tabular}{l|cccccc}
        \textbf{Requirements} & \textbf{\hyperref[req:personal]{R1}} & \textbf{\hyperref[req:configuration]{R2}} & \textbf{\hyperref[req:pedagogical]{R3}} & \textbf{\hyperref[req:simulations]{R4}} & \textbf{\hyperref[req:modern]{R5}} & \textbf{Total} \\ \hline
        \textbf{\hyperref[sec:review-prev-hc12sim]{hc12sim} \cite{Brightwell2013}} 
        & 3 & 1 & 4 & 2 & 3 & \textbf{15} \\
    \end{tabular}
    \caption{Qualitative requirement rating of hc12sim \cite{Brightwell2013}}
\end{table}

\subsection{ShelbySim}
\label{sec:review-shelbysim}

ShelbySim is an education-oriented software system for designing, simulating, and evaluating computer-engineering based applications \cite{Tappan2009, Tappan2009-2}. ShelbySim was designed surrounding a new Java-like programming language including a compiler explicitly built around providing extensive diagnostic information such as logging, tracing, and inspection capabilities. These tools provide students with raw data for quantitative analysis, evaluation and reporting of their designs. The software is open-source, though unavailable, and is written using Java allowing full operating system independent support. Additionally, graphical visualizations of results are provided for viewing developed components. ShelbySim is broken down into three subcomponents:
\begin{enumerate}
    \item Software component - a custom programming language (Shelby), a compiler, and an interpretation runtime
    \item Hardware component - filling a similar niche to MultiSim, but with tight integration with Shelby and its underlying tracing. Additional support exists for external component integration
    \item Simulation component - providing a deterministic and stochastic approach for recording inputs and outputs to custom hardware simulations
\end{enumerate} 

ShelbySim provides evaluation criterion for students' components and their underlying systems to aid in marking. The simulated components have parameters that are modifiable through switches and sliders (e.g. \{on, off\} or a range from 0 - 100\%). This gives students metrics to evaluate their designs. Additionally, outputs are exported at runtime to Comma Separated Value (CSV) files allowing for more in-depth analysis with external programs such as Microsoft Excel or MATLAB. This gives a flexible and realistic testing environment for student learning. 

\subsubsection*{Analysis of Requirements}

For \cref{req:personal}, ShelbySim is open-source and claims to run on all major platforms that the Java Virtual Machine runs on, thus it should work on Windows, macOS and GNU/Linux. ShelbySim is built as a custom programming language which is similar to Java but is used as an HDL. Given the inherent flexibility of HDL languages, \cref{req:configuration} is met, however these languages fall under a more complicated model than required for this thesis' use case, therein hurting \cref{req:pedagogical}. Further, ShelbySim focuses on compiler semantics and hardware configuration over ISA and embedded systems knowledge.  ShelbySim works well to provide quality simulations as required by \cref{req:simulations}. Additionally, ShelbySim produces comma-separated values of events which is useful for later analysis. Lastly, there does not appear to descriptions of a user interface component outside of graphical drawings. This does not concretely fail the modern interface component for \cref{req:modern}, but it does call into question how students may react to a lack of a proper programming environment. Additionally, there does not appear to be compiler features in place to utilize the custom ISA that a student creates (e.g. assembler).

\begin{table}[h!]
    \centering
    \begin{tabular}{l|cccccc}
        \textbf{Requirements} & \textbf{\hyperref[req:personal]{R1}} & \textbf{\hyperref[req:configuration]{R2}} & \textbf{\hyperref[req:pedagogical]{R3}} & \textbf{\hyperref[req:simulations]{R4}} & \textbf{\hyperref[req:modern]{R5}} & \textbf{Total} \\ \hline
        \textbf{\hyperref[sec:review-shelbysim]{ShelbySim} \cite{Tappan2009, Tappan2009-2}} & 4                                  & 4                                    & 3                            & 4                                  & 0                             & \textbf{15}    \\
    \end{tabular}
    \caption{Qualitative requirement rating of ShelbySim \cite{Tappan2009, Tappan2009-2}}
\end{table}

\subsection{EDCOMP: Flexible Web-Based Educational System}
\label{sec:review-edcomp}

EDCOMP is an educational computer system and a web-based simulator that can be used to cover computer architecture fundamentals; computer organization; computer arithmetic; memory hierarchies and organization; and simple input/output relations \cite{Djordjevic2005}. EDCOMP is written in Java and runs inside of a Java applet within a web browser. The simulator supports animation of instruction execution and allows students to write their own assembly programs, compile them and view the status of the machine components. All parts have visual components at multiple levels (i.e. module, combinational and sequential circuits). The simulation can be run at several levels per clock cycle, per instruction and for the entire program. Further, the simulation supports advanced topics such as interrupts and parallel I/O units. Lastly, timing diagrams allow students to see how components are interacting at a lower, discrete level. This software aims to create a system that focuses on pedagogical learning rather than on industrial accuracy and lower complexity of the system. EDCOMP focuses heavily on graphical representation to aid in student learning.

\subsubsection*{Analysis of Requirements}

For \cref{req:personal}, EDCOMP is written in Java and was previously run within a web browser inside of a Java applet intending to open access to students with a low barrier to entry. However, due to the deprecation of NPAPI\footnote{NPAPI: Netscape Plug-in API. Due to deprecation, documentation for this API does not exist, for a non-academic historical description see: \url{https://en.wikipedia.org/wiki/NPAPI}.} in Google Chrome, Chromium-based browsers, and Firefox, this means that likely over 80\% of students would not be able to use this software \cite{StatCounterBrowsers2017, W3SchoolsBrowsers2017, OracleJavaApplet2017, ChromiumBlogNPAPI2013, MozillaBlogNPAPI2016, GoogleChromeHelp2015}. In addition to being unusable with today's browsers, the system is also dated by the use of applets and does not have modern editor features creating a gap between modern technology and students therein failing to meet \cref{req:modern}. The EDCOMP system is not completely configurable as it is bound by purposeful reductions in features for pedagogical reasons. It features a CISC-based architecture with configurable components, however the internal connections can not be configured--only the size and ``shape'' of components. Thus, EDCOMP does not meet \cref{req:configuration}. EDCOMP heavily focuses on learning and teaching and showcases the use of a user interface to improve simulation triggers in a pedagogically focused way. The authors showcased the software by utilizing it within classrooms meeting \cref{req:pedagogical}. Finally, the simulations described are extremely useful and thorough. These simulations showcase powerful techniques in stepping and debugging and also triggering signals in meaningful ways to show students how different components can interact. The quality of these simulations strongly meets \cref{req:simulations}. 

\begin{table}[h!]
    \centering
    \begin{tabular}{lcccccc}
       \textbf{Requirements} & \textbf{\hyperref[req:personal]{R1}} & \textbf{\hyperref[req:configuration]{R2}} & \textbf{\hyperref[req:pedagogical]{R3}} & \textbf{\hyperref[req:simulations]{R4}} & \textbf{\hyperref[req:modern]{R5}} & \textbf{Total} \\ \hline
       \textbf{EDCOMP \cite{Djordjevic2005}} 
       & 3 & 3 & 4 & 4 & 0 & \textbf{14} \\ 
    \end{tabular}
    \caption{Qualitative requirement rating of EDCOMP \cite{Djordjevic2005}}
\end{table}

\subsection{p88110: A Graphical Simulator for Computer Architecture and Organization Courses}
\label{sec:review-p88110}

The p88110 attempts to cover many core topics in Computer Architecture and Organization \cite{Garcia2009}. The authors reflected and have created a ``one-size fits all'' solution to try and replace many heterogeneous simulators used in practice at the time. This software emulates the ISA for the MC88110 microprocessor specifically -- a RISC architecture. The authors intentionally removed components to alleviate the amount of information for students to learn. The user interface includes a view for the current simulation of components, and a simplistic, built-in editor and simulation stepping at the instruction level and adding debugging breakpoints. The simulator can be modified to execute in serial or parallel (super-scalar) modes. In parallel mode, the four-stage pipeline of the MC88110 is implemented with static branch prediction and delays. A unique feature is the use of built-in caches for instructions and memory. These include configuration for time-to-read and write. During simulation, cache and branch prediction hit and miss statistics are recorded for student analysis purposes. The authors have implemented this simulator in class assignments and created an automated evaluation tool for reducing overhead for instructors. 

\subsubsection*{Analysis of Requirements}

The authors claim that the p88110 simulator may be run on personal computers, however given changing technologies and a lack of software description, we could not validate the software is still able to run on current operating systems implying the system does not meet \cref{req:personal}. p88110 directly emulates the MC88110 system which is a similar system to the \hcmodel{} and has been shown to be an excellent candidate for pedagogical purposes. \Cref{req:configuration} states that a software must be able to be configured for multiple architectures and while the MC88110 is a great candidate architecture specifically, p88110 is too limited to meet this requirement. However, the engine configuration features presented by p88110 are extremely powerful and useful. p88110 was developed for use within a classroom meeting \cref{req:pedagogical}. Further, p88110 reduced realism to create a simpler architecture for students to learn from -- favouring pedagogy over accuracy. Additionally, the use of an automatic marking tool would reduce the overhead for teaching students and give students instant feedback without requiring instructor interaction. The simulations provided by p81100 are thorough and provide insight into statistical modelling of pipelined and cached architectures. This information is extremely relevant to computer architecture courses. However, the p88110 does not support the use of peripherals or interrupts. \Cref{req:simulations} is not met due to lacking features, though the statistical feedback provides an interesting insight for students to learn from. Lastly, the interface is not modern and supports only simple features found in most editors. The amount of dialogs created shows concern for focus when working with p88110 and does not reduce students cognitive workload therein failing to meet \cref{req:modern}. 

\begin{table}[h!]
    \centering
    \begin{tabular}{lcccccc}
        \textbf{Requirements} & \textbf{\hyperref[req:personal]{R1}} & \textbf{\hyperref[req:configuration]{R2}} & \textbf{\hyperref[req:pedagogical]{R3}} & \textbf{\hyperref[req:simulations]{R4}} & \textbf{\hyperref[req:modern]{R5}} & \textbf{Total} \\ \hline
        \textbf{p88110 \cite{Garcia2009}}
        & 1 & 1 & 4 & 3 & 1 & \textbf{10} \\
    \end{tabular}
    \caption{Qualitative requirement rating of p88110 \cite{Garcia2009}}
\end{table}

\subsection{EASE - An Extensible Architecture Simulation Engine}
\label{sec:review-ease}

Extensible Architecture Simulation Engine (EASE) is a simulation engine focused on custom simulations for classroom use \cite{Skillen2011}. EASE attempts to provide the following features: 
\begin{itemize}
    \item Support for multiple architecture types: RISC, CISC and URISC
    \item Provide a modular mechanism for simple extension
    \item Open-source software
    \item Portable to different platforms
\end{itemize}
The authors \cite{Skillen2011} reviewed the survey of simulation tools found in \cite{Nikolic2009} and found the suggested tools were inadequate for teaching simulation architecture courses based on their requirements. Many put too much emphasis on RTL descriptions of the hardware and too little on ISA. EASE provides three ISAs for use, a CISC, RISC and URISC within the project. EASE is written in Java making it cross-platform. It comes with a very simple user interface written in Java Swing. 

\subsubsection*{Analysis of Requirements}

EASE is a very immature project without a lot of proven use--this makes it difficult to gauge how effective it is. EASE focuses on pedagogy as it's major requirement meeting \cref{req:pedagogical}. While the authors mention new architectures may be added through implementation of their \javainline{interface Arch}, students have no way to do this themselves and forces a recompiling of the application to create a new architecture therein failing to meet \cref{req:configuration}. Given that EASE is written with Java, all that is required to run the software is a Java runtime making it cross-platform. However, \cite{Skillen2011} stated the software was available under the GNU Public License v3, but the software is not currently available for consumption. Theoretically EASE meets \cref{req:personal} through using the Java Virtual Machine for it's environment but we could not verify this. EASE does support step-based execution, however it has no support for debug breakpoints. Further, there is no reference to stepping at the microcode level. Runtime viewing of registers is available, however there is no way to view the memory. These outlined features do not meet \cref{req:simulations}. Lastly, the user interface provided is very simple providing syntax highlighting for a single file and simple debugging controls. The interface does not provide modern editing features that students are accustomed to with most editors -- failing to meet \cref{req:modern}.

\begin{table}[h!]
    \centering
    \begin{tabular}{lcccccc}
        \textbf{Requirements} & \textbf{\hyperref[req:personal]{R1}} & \textbf{\hyperref[req:configuration]{R2}} & \textbf{\hyperref[req:pedagogical]{R3}} & \textbf{\hyperref[req:simulations]{R4}} & \textbf{\hyperref[req:modern]{R5}} & \textbf{Total} \\ \hline
        \textbf{EASE \cite{Skillen2011}}
        & 4 & 2 & 5 & 3 & 2 & \textbf{16} \\
    \end{tabular}
    \caption{Qualitative requirement rating of EASE \cite{Skillen2011}}
\end{table}

\subsection{TinyCPU and TinyCSE: Hardware simulations for education}
\label{sec:review-tiny-cse}

TinyCPU is a teaching assignment designed to be used in a Masters of Science program in embedded systems to teach students about computer architectures by having them incrementally design a CPU (TinyCPU) \cite{McLoughlin2010}. TinyCPU has been used in a program described to be very similar to \uwo's computer engineering program. TinyCPU runs in Verlilog and is a simple stack-based machine. The full block diagram for TinyCPU is shown in \cref{fig:mcloughlin2010-tinycpu-block-diagram}. The architecture is meant to be extremely simple to mitigate extra information for students to consume. The entire CPU configuration is rigidly bound with:
\begin{itemize}
    \item 16-bit word size
    \item 12-bit address space
    \item A single ALU
    \item Dual bus structure with a data bus (dbus) and address bus (abus)
\end{itemize}
The CPU is compiled with a Verlilog tool chain (e.g. Xilinx ISE) and loaded onto either a hardware or software-simulated FPGA to run. The execution model is intentionally simplistic for improving ease of learning (shown in \cref{fig:mcloughlin2010-tinycpu-state-chart}). Given that TinyCPU is written in Verlilog, it works well with existing industry tools such as ModelSim. Lastly, there exists a C compiler and assembler for TinyCPU making a very strong case for modern programming interactions. 

\begin{figure}[t!]
    \centering
    \includegraphics[width=0.7\linewidth]{img/mcloughlin2010-tinycpu-block-diagram}
    \caption{Block diagram of TinyCPU showing the internal architecture \cite[p.~869]{McLoughlin2010}}
    \label{fig:mcloughlin2010-tinycpu-block-diagram}
    \includegraphics[width=0.7\linewidth]{img/mcloughlin2010-tinycpu-execution-state-chart}
    \caption{State chart of TinyCPU execution path \cite[p.~869]{McLoughlin2010}}
    \label{fig:mcloughlin2010-tinycpu-state-chart}
\end{figure}

TinyCSE is an extension to TinyCPU that provides a full system supporting hardware interrupts that can interact with peripheral components like mice and keyboards \cite{Nakamura2013}. TinyCSE adds an I/O space memory mapping controller for interacting with peripherals. This allows I/O components to ``register'' themselves into a position and programs in TinyCSE can read/write to I/O components through memory mapping. Further, TinyCSE adds an interrupt flag that the state machine utilizes to allow for hardware interrupts. These interrupts are extremely important as this is how most hardware devices interact with a CPU. The modified state diagram is shown in \cref{fig:nakamura2013-tinycse-execution-state-chart}. At an architectural level, interrupts are supported via \verb|CALL| and \verb|RETURN| instructions which branch to an interrupt routine and return from an interrupt routine respectively while maintaining the stack.

\begin{figure}[b!]
    \centering
    \includegraphics[width=0.7\linewidth]{img/nakamura2013-tinycse-execution-state-chart}
    \caption{TinyCSE execution state diagram modified from \cref{fig:mcloughlin2010-tinycpu-state-chart} to include interrupts (broken lines show changes from TinyCPU \cite{McLoughlin2010}) \cite[p.~640]{Nakamura2013}}
    \label{fig:nakamura2013-tinycse-execution-state-chart}
\end{figure}

\subsubsection*{Analysis of Requirements}

For the purposes of analysis, this section will only consider TinyCSE as it is a super-set of TinyCPU functionality. TinyCSE focuses on pedagogy first and foremost, but also focuses on a hardware descriptor language, Verlilog. While Verlilog is a very powerful tool, it requires a complicated tool-chain creating complications for the purpose of teaching introductory courses -- we do acknowledge the authors intended on utilizing TinyCSE for Masters of Science students. Additionally, the software required for typical Verlilog environments is very expensive and not accessible to the average student. This does not fully meet the requirements of \cref{req:pedagogical,,req:personal}. The simulations provided by TinyCSE provide more information than any other simulator evaluated at the expense of complexity for the system and a high barrier of entry to configure the simulator. This barrier creates a large enough gap that TinyCSE does not meet \cref{req:configuration} (see the discussion in \cref{sec:motivation} for a discussion on existing hardware IDEs). While failing to meet \cref{req:configuration}, due to the level of simulation granularity \cref{req:simulations} is easily met given existing industry tools. Lastly, the software provides no user interface of it's own and requires the use of a Verlilog IDE and FPGA programming software. These tools are modern and updated regularly, however they often fail to have the editor/IDE features students are used to not meeting \cref{req:modern}.

\begin{table}[h!]
    \centering
    \begin{tabular}{lcccccc}
        \textbf{Requirements} & \textbf{\hyperref[req:personal]{R1}} & \textbf{\hyperref[req:configuration]{R2}} & \textbf{\hyperref[req:pedagogical]{R3}} & \textbf{\hyperref[req:simulations]{R4}} & \textbf{\hyperref[req:modern]{R5}} & \textbf{Total} \\ \hline
        \textbf{TinyCPU/TinyCSE \cite{Nakamura2013, McLoughlin2010}} 
        & 2 & 3 & 3 & 4 & 3 & \textbf{15} \\ 
    \end{tabular}
    \caption{Qualitative requirement rating of TinyCPU/TinyCSE \cite{Nakamura2013, McLoughlin2010}}
\end{table}

\subsection{CPU Sim}
\label{sec:review-cpu-sim}

CPU Sim is a Java CPU simulator written for use within a classroom environment \cite{Skrien2001}. CPU Sim allows students to design, modify, and compare various computer architectures at the register-transfer level and higher. Additionally, students may write and debug assembly code for custom architectures. The simulator and IDE are written in Java, with the latter utilizing Oracle's JavaFX user interface. The software is currently available from \cite{Skrien2017} as ``freeware.'' In conversations with Dr. Skrien, he expressed the want to open source CPU Sim in the future to increase availability \cite{Skrien2016}. The user interface is feature rich allowing students to configure a processor with:
\begin{itemize}
    \item Hardware specifications (e.g. RAM word size, length),
    \item Hardware inter-connections,
    \item Processor microcodes,
    \item Assembly instructions,
\end{itemize} 
These specifications gives students the ability to configure a nearly custom processor. However, using the current 4.0.10 release, configuration options are missing: clock speed changes, CISC-like addressing modes, and peripheral support
\cite{Skrien2017}. Using Java technologies allows CPU Sim to work with the three major platforms as a desktop application. CPU Sim's IDE provides a modern assembly editor for custom architectures providing syntax highlighting, tabbed editor panes and simple editor commands like find-and-replace. During a simulation, CPU Sim allows students to view memory and register states. \Cref{fig:skrien2017-cpusim-desktop} shows the IDE during a simple simulation with a program written in a custom ISA open for editing. CPU Sim fully supports debug points and step-based execution in it's engine. Unfortunately the execution engine is very simplistic and does not provide any configuration points outside of changing the instruction fetch microcode sequence. 

\begin{figure}[t!]
    \centering
    \includegraphics[width=0.9\linewidth]{img/skrien2017-cpusim-desktop}
    \caption{CPU Sim 4.0.0 IDE during debugging with Assembly Editor open \cite{Skrien2017}}
    \label{fig:skrien2017-cpusim-desktop}
\end{figure}

CPU Sim supports creating custom assembly languages to ``compile'' to the a custom ISA. Assembly or ``microinstructions'' in the context of CPU Sim are specified as sequences of ``machine instructions.'' Each ``microinstruction'' is a single transfer or operation within the CPU. For example, ``transfer between registers,'' ``read from memory'' or ``branch if condition bit.'' These microinstructions are configured based on hardware specifications. When designing an assembly instruction, the microcode is laid out with a drag-and-drop interface placing ``fields.'' The drag and drop interface is shown in \cref{fig:skrien2017-cpusim-machine-instruction}. The top layout shows the microcode, the bottom is the ``assembly'' layout which designates how the instruction is written in an assembly program. These values can be rearranged independent of each other, though relative ordering of repeated values is maintained. These interfaces allow for adding punctuation and non-encoded values to the assembly layout. This is a very powerful feature as the assembler provided will parse the custom assembly layouts to produce compliant microcode.

\begin{figure}[t!]
    \centering
    \includegraphics[width=0.7\linewidth]{img/skrien2017-cpusim-machine-instruction}
    \caption{CPU Sim Machine Instruction configuration interface showing combination of fields to create a microcode and an assembly instruction.}
    \label{fig:skrien2017-cpusim-machine-instruction}
\end{figure}

Lastly, CPU Sim contains excellent documentation within it's internal help program. The help documentation is very deep and has many images and ``tutorial style'' documentation embedded internally. The author used this documentation exclusively to learn how to use CPU Sim and found it very useful. This documentation in particular makes CPU Sim attractive to prospective instructors due to the reduction in student inquiries as most questions may be found in the program itself. 


\subsubsection*{Analysis of Requirements}

CPU Sim is readily available for use by downloading it from \cite{Skrien2017}. The software runs well on Microsoft Windows and Linux. macOS support is available, however it has some non-critical user interface bugs that make it feel slightly ``foreign'' on macOS (e.g. the menu bar does not reside in the operating system menu bar). This strongly meets \cref{req:personal} as it runs well on the three major platforms. The assembly editor has many modern features which leads well to having students feel as though they are using a modern software. However when configuring hardware modules, the user interface is difficult to navigate and does not always use suitable user interface components to better utilize the available space. \Cref{fig:skrien2017-cpusim-microinstructions} shows the module modification interface for the Transfer Register to Register Array interface. The interface presented does not scale and for different modules, there exists many disjointed user interface components where the same ``expected action'' between two different dialogs is completed a different way. In our experience, this lead to confusing amongst those using the software. Unfortunately, these usability concerns hinder both \cref{req:modern,req:pedagogical} severely. 

\begin{figure}[th!]
    \centering
    \includegraphics[width=0.7\linewidth]{img/skrien2017-cpusim-microinstructions}
    \caption{CPU Sim 4.0.0 IDE module specification dialog showing modification of Transfer Register to Register Array microinstruction \cite{Skrien2017}}
    \label{fig:skrien2017-cpusim-microinstructions}
\end{figure}

While usability is impacted, the simplicity of these interfaces improves the pedagogical outcomes by removing non-essential information which supports \cref{req:pedagogical}. Dr. Skrien's intention to open source CPU Sim should improve student learning by allowing students to investigate the source code within \cite{Skrien2016,Coppola2004,Koohang2005}. The large amount of configuration available strongly supports \cref{req:configuration}; however due to missing features such as changing how the simulator executes code and the addition of external peripherals CPU Sim is not a perfect match for \cref{req:configuration}. Lastly, CPU Sim's simulations are very accurate and the user interface makes it simple to watch modules within the simulated engine partially meeting \cref{req:simulations} -- though external peripherals are missing.

\begin{table}[h!]
    \centering
    \begin{tabular}{lcccccc}
        \textbf{Requirements} & \textbf{\hyperref[req:personal]{R1}} & \textbf{\hyperref[req:configuration]{R2}} & \textbf{\hyperref[req:pedagogical]{R3}} & \textbf{\hyperref[req:simulations]{R4}} & \textbf{\hyperref[req:modern]{R5}} & \textbf{Total} \\ \hline
        \textbf{CPU Sim \cite{Skrien2001, Skrien2001}}
        & 5 & 4 & 4 & 2 & 3 & \textbf{18} \\
    \end{tabular}
    \caption{Qualitative requirement rating of CPU Sim \cite{Skrien2001, Skrien2001}}
\end{table}

\subsection{Emumaker86: A Hardware Simulator for Teaching CPU Design}
\label{sec:review-emumaker86}

Emumaker86 is an entirely GUI-based hardware simulator for designing CPUs in a Computer Organization course \cite{Black2013}. Emumaker86 is written in Java and is a desktop-based application. Emumaker86 is integrated on top of an existing personal computer simulator giving Emumaker86 full access to PC-compatible peripherals (e.g. video controller, CD drive). Emumaker86 attempts to keep students at a higher level than digital circuit simulators, abstracting away flip-flops and logic gates into registers and ALUs respectively. Emumaker86 breaks CPU design into two main components, 1. Datapath and 2. Control unit. These two are built independently from each other in custom user interfaces. 

The Datapath builder works by students specifying RTL-like structures with digital components. Each of these components are laid out and connected through wires and buses. Any clocked component is connected to the ``system'' clock by design to simplify requirements for students. There are interrupt and I/O ports available to enable peripheral connections. These components can be combined to create sub-components as an abstraction. Each component runs in parallel within the device. All of these components and datapath entities are serialized as XML so they can be saved, distributed and reloaded. 

The control builder is an interface used to specify a state machine with transitions and control unit states. The interface is shown in \cref{fig:emumaker86-control-builder}. Each colour corresponds to a different field, for example blue is the current state label, below it yellow are microcode rows and green are ``Next States.'' State transitions are based on ``conditional bits'' such as ``opcode,'' ``zero,'' or ``shortopcode.'' This represents the control unit as a finite state machine, a common topic in Computer Science and Engineering curricula \cite{cec2016}. 

\begin{figure}[tp!]
    \centering
    \includegraphics[width=0.7\linewidth]{img/emumaker86-control-builder}
    \caption{Emubuilder86 Control Builder: State machine definition \cite[p.~325]{Black2013}}
    \label{fig:emumaker86-control-builder}
\end{figure}

\subsubsection*{Analysis of Requirements}

Enumaker86 meets most of the requirements outlined in \cref{sec:problem-statement}. However, it is not without issue. For \cref{req:personal}, a minor concern is that the software runs on Java requiring a desktop environment. Similar to \cite{McLoughlin2010,Nakamura2013}, Emumaker86 uses state machines to represent the control unit. The largest difference is that Emumaker86 allows for the state machine to be changed by users. Allowing students to change how the control unit functions is essential to give students experience designing a controller. Additionally, the ``Datapath'' creation mechanism uses a graphical way of designing the hardware controls while still hiding the internals of supplied components. Emumaker86 meets \cref{req:pedagogical}. There does not appear to be any assembler mechanism requiring code to be hand-compiled to work on any architecture created (barring an existing architectural tool chain). Given the lack of an assembler, there is no assembly-level debugging -- failing to meet \cref{req:simulations}. Lastly, the largest concern is the need for modern features. The interface provided for working with the state machine is extremely hard to read as it utilizes a table-like structure relying on colour coding over modern user interface design paradigms.

\begin{table}[h!]
    \centering
    \begin{tabular}{lcccccc}
        \textbf{Requirements} & \textbf{\hyperref[req:personal]{R1}} & \textbf{\hyperref[req:configuration]{R2}} & \textbf{\hyperref[req:pedagogical]{R3}} & \textbf{\hyperref[req:simulations]{R4}} & \textbf{\hyperref[req:modern]{R5}} & \textbf{Total} \\ \hline
        \textbf{Emumaker86 \cite{Black2013}}
        & 4 & 5 & 5 & 2 & 2 & \textbf{18} \\ 
    \end{tabular}
    \caption{Qualitative requirement rating of Emumaker86 \cite{Black2013}}
\end{table}

\section{Summary}
\label{sec:review-summary}

Given the results accumulated through our best effort objective comparison in \cref{sec:review}, the results were tabulated into \cref{table:simulator-evaluation-summary}. Naively, out of the simulations, CPU Sim \cite{Skrien2001,Skrien2017} and Emumaker86 \cite{Black2013} have the largest total match for the requirements. This information was considered when selecting a trajectory for the thesis' project, however the raw numbers do not extract enough information. Each simulator project has design ideas that can be combined into a better software to meet the requirements from \cref{sec:problem-statement}. 

\begin{table}[h!]
    \centering
    \begin{tabular}{lcccccc}
        \textbf{Requirements} & \textbf{\hyperref[req:personal]{R1}} & \textbf{\hyperref[req:configuration]{R2}} & \textbf{\hyperref[req:pedagogical]{R3}} & \textbf{\hyperref[req:simulations]{R4}} & \textbf{\hyperref[req:modern]{R5}} & \textbf{Total} \\ \hline
        
        \textbf{\hyperref[sec:review-prev-hc12sim]{hc12sim} \cite{Brightwell2013}} 
        & 3 & 1 & 4 & 2 & 3 & \textbf{13} \\
        \textbf{\hyperref[sec:review-shelbysim]{ShelbySim} \cite{Tappan2009, Tappan2009-2}} 
        & 4 & 4 & 3 & 4 & 0 & \textbf{15} \\
        \textbf{\hyperref[sec:review-edcomp]{EDCOMP} \cite{Djordjevic2005}}
        & 3 & 3 & 4 & 4 & 0 & \textbf{14} \\
        \textbf{\hyperref[sec:review-p88110]{p88110} \cite{Garcia2009}}
        & 1 & 1 & 4 & 3 & 1 & \textbf{10}  \\
        \textbf{\hyperref[sec:review-ease]{EASE} \cite{Skillen2011}}
        & 4 & 2 & 5 & 3 & 2 & \textbf{16} \\
        \textbf{\hyperref[sec:review-tiny-cse]{TinyCPU/TinyCSE} \cite{Nakamura2013,McLoughlin2010}} 
        & 2 & 3 & 3 & 4 & 3 & \textbf{15} \\
        \textbf{\hyperref[sec:review-cpu-sim]{CPU Sim} \cite{Skrien2001, Skrien2017}}
        & 5 & 4 & 4 & 2 & 3 & \textbf{18} \\
        \textbf{\hyperref[sec:review-emumaker86]{Emumaker86} \cite{Black2013}} 
        & 4 & 5 & 5 & 2 & 2 & \textbf{18} \\ 
    \end{tabular}
    \caption{Summary of Evaluation for Simulators}
    \label{table:simulator-evaluation-summary}
\end{table}

The hc12sim project provided a very fast, cross-platform system, but similar to EASE, it was bound to compile-time configuration. Work completed on the hc12sim project lead us to develop the idea of runtime-configurable simulations (a known entity in other projects, e.g. CPU Sim \cite{Skrien2001} and Emumaker86 \cite{Black2013}). This runtime-configurable feature is paramount in any project moving forward. Further, several other projects had distinguishing features that should be included future projects. 

The first significant feature is the use of ``event-driven'' simulation that TinyCSE \cite{Nakamura2013, McLoughlin2010} and p88110 \cite{Garcia2009} suggested. Event-driven simulation allows for a simpler approach to maintaining state within a simulation. Event-driven simulation models are further discussed in both \cref{ch:scala-akka,,ch:lua}. Another feature found to be extremely useful is the use of stochastic model outputs that can be integrated with existing tools. All of EDCOMP \cite{Djordjevic2005}, ShelbySim \cite{Tappan2009, Tappan2009-2}, TinyCSE \cite{Nakamura2013, McLoughlin2010} and p88110 \cite{Garcia2009} provide tooling to integrate with existing tools such as ModelSim, Excel or MATLAB. While dependence on industry tools can create problems for pedagogical reasons, allowing for integration points with these tools gives students more experience with industry prevalent tools -- particularly ModelSim and Excel. 

A feature only provided by TinyCSE \cite{Nakamura2013, McLoughlin2010} and Emumaker86 \cite{Black2013} is the ability to configure the entire execution loop. TinyCSE \cite{Nakamura2013,McLoughlin2010} does this by utilizing Verlilog and having students adjust the state machine directly. Emumaker86 \cite{Black2013} takes an entirely different approach having students specify a state machine based on input signals and state of components. Emumaker86 \cite{Black2013}'s approach gives student's the most power in configuring a machine and uses a familiar concept of finite state machines \cite{cec2016}. The implementation falls flat due to the hard-to-use user interface (shown in \cref{fig:emumaker86-control-builder}). Students are used to seeing machines as \cref{fig:nakamura2013-tinycse-execution-state-chart} displays. A system that gives the power of the ``table-based'' approach of Emumaker86 with the visual queues from the state chart would give both familiarity and power to students.

Lastly, CPU Sim \cite{Skrien2001} provides two features that appear to be distinct: 1. Strong accompanying documentation, 2. Assembler configuration. Documentation is important for any software to be heavily utilized, particularly if it is to be used by novice users. CPU Sim's assembler configuration allows students to create their own assembly-level language tied into their custom ISA.  
